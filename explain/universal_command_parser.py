"""Universal Command Parser for Structured AutoGen Output

This module provides a clean, universal parser for structured commands
generated by AutoGen agents, eliminating the need for complex regex
pattern matching and micromanagement.

The parser takes structured JSON commands and translates them into
executable actions using the dynamic code generation framework.
"""

import json
import logging
from typing import Dict, List, Any, Optional, Tuple

logger = logging.getLogger(__name__)


class UniversalCommandParser:
    """
    Universal parser for structured commands from AutoGen agents.
    
    This parser handles the universal command structure:
    {
        "filters": [{"feature": "age", "operator": "greater", "value": 50}],
        "function": "predict",
        "params": {"instance_id": 5, "metric": "accuracy"}
    }
    
    Philosophy:
        - No regex patterns or micromanagement
        - Universal structure works for any feature combination
        - Clean separation between filtering and function execution
        - Maintains full generalizability of the original system
    """
    
    def __init__(self):
        """Initialize the universal command parser."""
        self.supported_functions = {
            'predict', 'explain', 'important', 'score', 
            'data', 'change', 'mistake', 'show'
        }
        self.supported_operators = {
            'greater', 'less', 'equal', 'greaterequal', 'lessequal'
        }
    
    def parse_command(self, command_structure: Dict[str, Any]) -> List[str]:
        """
        Parse universal command structure into executable action list.
        
        Args:
            command_structure: Universal command structure from AutoGen
            
        Returns:
            List of executable action strings for the dynamic code generator
        """
        try:
            # Validate command structure
            if not self._validate_command_structure(command_structure):
                logger.error(f"Invalid command structure: {command_structure}")
                return ["data"]  # Fallback to data summary
            
            filters = command_structure.get('filters', [])
            function = command_structure.get('function', 'data')
            params = command_structure.get('params', {})
            
            # Build action list
            actions = []
            
            # Add filter actions
            for filter_spec in filters:
                filter_action = self._build_filter_action(filter_spec)
                if filter_action:
                    actions.append(filter_action)
            
            # Add function action
            function_action = self._build_function_action(function, params)
            if function_action:
                actions.append(function_action)
            
            # Return actions or fallback
            return actions if actions else ["data"]
            
        except Exception as e:
            logger.error(f"Error parsing command structure: {e}")
            return ["data"]  # Safe fallback
    
    def _validate_command_structure(self, command: Dict[str, Any]) -> bool:
        """Validate the universal command structure."""
        try:
            # Check required fields
            if 'function' not in command:
                return False
            
            # Validate function
            function = command['function']
            if function not in self.supported_functions:
                logger.warning(f"Unsupported function: {function}")
                return False
            
            # Validate filters if present
            filters = command.get('filters', [])
            if not isinstance(filters, list):
                return False
            
            for filter_spec in filters:
                if not self._validate_filter(filter_spec):
                    return False
            
            # Validate params if present
            params = command.get('params', {})
            if not isinstance(params, dict):
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Error validating command structure: {e}")
            return False
    
    def _validate_filter(self, filter_spec: Dict[str, Any]) -> bool:
        """Validate a single filter specification."""
        try:
            # Check required fields
            required_fields = ['feature', 'operator', 'value']
            for field in required_fields:
                if field not in filter_spec:
                    return False
            
            # Validate operator
            operator = filter_spec['operator']
            if operator not in self.supported_operators:
                logger.warning(f"Unsupported operator: {operator}")
                return False
            
            # Validate feature name (basic check)
            feature = filter_spec['feature']
            if not isinstance(feature, str) or not feature.strip():
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Error validating filter: {e}")
            return False
    
    def _build_filter_action(self, filter_spec: Dict[str, Any]) -> Optional[str]:
        """Build filter action string from filter specification."""
        try:
            feature = filter_spec['feature']
            operator = filter_spec['operator']
            value = filter_spec['value']
            
            # Handle special case for ID filtering
            if feature.lower() == 'id':
                return f"filter id {value}"
            
            # Standard filter format
            return f"filter {feature} {operator} {value}"
            
        except Exception as e:
            logger.error(f"Error building filter action: {e}")
            return None
    
    def _build_function_action(self, function: str, params: Dict[str, Any]) -> Optional[str]:
        """Build function action string from function and parameters."""
        try:
            if function == 'predict':
                instance_id = params.get('instance_id')
                if instance_id is not None:
                    return f"predict {instance_id}"
                return "predict"
            
            elif function == 'explain':
                instance_id = params.get('instance_id')
                method = params.get('method', 'general')
                if instance_id is not None:
                    return f"explain {instance_id} {method}"
                return "explain"
            
            elif function == 'important':
                scope = params.get('scope', 'all')
                if scope == 'topk':
                    topk_count = params.get('topk_count', 5)
                    return f"important topk {topk_count}"
                return "important all"
            
            elif function == 'score':
                metric = params.get('metric', 'accuracy')
                return f"score {metric}"
            
            elif function == 'data':
                return "data"
            
            elif function == 'change':
                feature = params.get('feature')
                operation = params.get('operation')
                new_value = params.get('new_value')
                if all([feature, operation, new_value is not None]):
                    return f"change {feature} {operation} {new_value}"
                return None
            
            elif function == 'mistake':
                return "mistake"
            
            elif function == 'show':
                instance_id = params.get('instance_id')
                if instance_id is not None:
                    return f"show {instance_id}"
                return "show"
            
            else:
                logger.warning(f"Unknown function: {function}")
                return None
                
        except Exception as e:
            logger.error(f"Error building function action: {e}")
            return None
    
    def parse_autogen_response(self, autogen_response: Dict[str, Any]) -> List[str]:
        """
        Parse AutoGen response containing universal command structure.
        
        Args:
            autogen_response: Response from AutoGen action planning agent
            
        Returns:
            List of executable action strings
        """
        try:
            # Extract command structure from AutoGen response
            if 'action' in autogen_response:
                # Handle legacy format
                command_structure = autogen_response['action']
            elif 'command' in autogen_response:
                # Handle new universal format
                command_structure = autogen_response['command']
            else:
                logger.error("No command structure found in AutoGen response")
                return ["data"]
            
            # Parse the command structure
            return self.parse_command(command_structure)
            
        except Exception as e:
            logger.error(f"Error parsing AutoGen response: {e}")
            return ["data"]


def create_universal_parser() -> UniversalCommandParser:
    """Factory function to create universal command parser."""
    return UniversalCommandParser() 